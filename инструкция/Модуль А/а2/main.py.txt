from __future__ import annotations

import argparse
import json
from datetime import datetime, timezone

from sqlalchemy import func

from shared.db import engine, get_session
from shared.logging import setup_logger
from shared.models import Base, Track, TrackPoint, WeatherPoint
from shared.dataset_models import DatasetPoint
from shared.config import settings

from agents.a2_features.services.geo_features import slope_deg
from agents.a2_features.services.context_from_tiles import extract_context
from agents.a2_features.services.settlements import distance_to_nearest_settlement_m

logger = setup_logger("agent_a2_features")


def ensure_db() -> None:
    Base.metadata.create_all(bind=engine)


def run(
    radius_m: int,
    skip_context: bool,
    skip_settlement: bool,
    context_step: int = 10,
) -> None:
    """
    Формирует dataset_points: одна строка на одну точку маршрута.
    context_step: считать окружение каждую N-ю точку, остальные берут ближайший контекст (ускорение).
    """
    ensure_db()
    sess = get_session()

    tracks = sess.query(Track).all()
    logger.info(
        f"tracks found: {len(tracks)}; radius_m={radius_m}; "
        f"skip_context={skip_context}; skip_settlement={skip_settlement}; context_step={context_step}"
    )

    for track in tracks:
        points = (
            sess.query(TrackPoint)
            .filter(TrackPoint.track_id == track.id)
            .order_by(TrackPoint.seq)
            .all()
        )
        logger.info(f"track_id={track.id} points={len(points)}")

        if not points:
            continue

        # Погодные точки трека (железно через join, без reliance на relationship)
        weather_rows = (
            sess.query(
                WeatherPoint.track_point_id.label("tp_id"),
                WeatherPoint.temp_c.label("temp_c"),
                WeatherPoint.precipitation_mm.label("precipitation_mm"),
                WeatherPoint.humidity_pct.label("humidity_pct"),
                WeatherPoint.wind_ms.label("wind_ms"),
                TrackPoint.seq.label("seq"),
                TrackPoint.ts.label("ts"),
            )
            .join(TrackPoint, TrackPoint.id == WeatherPoint.track_point_id)
            .filter(TrackPoint.track_id == track.id)
            .all()
        )

        inserted = 0
        cached_ctx = None

        for i, p in enumerate(points):
            exists = (
                sess.query(DatasetPoint)
                .filter(DatasetPoint.track_point_id == p.id)
                .one_or_none()
            )
            if exists:
                continue

            prev_p = points[i - 1] if i - 1 >= 0 else None
            next_p = points[i + 1] if i + 1 < len(points) else None

            sdeg = slope_deg(prev_p, next_p)

            # time fallback: если в точке нет времени — используем started_at трека
            ts = p.ts or track.started_at

            # Окружение: считаем не для каждой точки, а батчами (ускорение)
            if skip_context:
                land_type = None
                objects = []
                frac_road = frac_building = frac_water = frac_vegetation = None
                green_index = None
            else:
                if cached_ctx is None or (context_step > 0 and (i % context_step == 0)):
                    cached_ctx = extract_context(p.lat, p.lon, radius_m=radius_m)

                land_type = cached_ctx.land_type
                objects = cached_ctx.objects
                frac_road = cached_ctx.frac_road
                frac_building = cached_ctx.frac_building
                frac_water = cached_ctx.frac_water
                frac_vegetation = cached_ctx.frac_vegetation
                green_index = cached_ctx.green_index

            # Дистанция до населённого пункта (может быть None, если сеть/лимиты)
            dist_set = None
            if not skip_settlement:
                dist_set = distance_to_nearest_settlement_m(p.lat, p.lon)

            # Погода:
            # 1) точная запись по track_point_id, если есть
            # 2) иначе: подбираем ближайшую по времени (если есть ts) или по seq
            w = (
                sess.query(WeatherPoint)
                .filter(WeatherPoint.track_point_id == p.id)
                .one_or_none()
            )

            if w is not None:
                temp_c = w.temp_c
                precipitation_mm = w.precipitation_mm
                humidity_pct = w.humidity_pct
                wind_ms = w.wind_ms
            else:
                temp_c = precipitation_mm = humidity_pct = wind_ms = None

                if weather_rows:
                    best = None
                    best_d = None

                    if ts is not None:
                        for r in weather_rows:
                            if r.ts is None:
                                continue
                            d = abs((r.ts - ts).total_seconds())
                            if best is None or d < best_d:
                                best = r
                                best_d = d
                    else:
                        for r in weather_rows:
                            d = abs(r.seq - p.seq)
                            if best is None or d < best_d:
                                best = r
                                best_d = d

                    if best is not None:
                        temp_c = best.temp_c
                        precipitation_mm = best.precipitation_mm
                        humidity_pct = best.humidity_pct
                        wind_ms = best.wind_ms

            row = DatasetPoint(
                track_id=track.id,
                track_point_id=p.id,
                region=track.region,
                ts=ts,
                lat=p.lat,
                lon=p.lon,
                ele=p.ele,
                radius_m=radius_m,
                slope_deg=sdeg,
                dist_to_settlement_m=dist_set,
                green_index=green_index,
                temp_c=temp_c,
                precipitation_mm=precipitation_mm,
                humidity_pct=humidity_pct,
                wind_ms=wind_ms,
                land_type=land_type,
                objects_json=json.dumps(objects, ensure_ascii=False),
                frac_road=frac_road,
                frac_building=frac_building,
                frac_water=frac_water,
                frac_vegetation=frac_vegetation,
                created_at=datetime.now(timezone.utc),
            )

            sess.add(row)
            inserted += 1

            if inserted % 500 == 0:
                sess.commit()
                logger.info(f"track_id={track.id} committed inserted={inserted}")

        sess.commit()
        logger.info(f"track_id={track.id} done inserted={inserted}")


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--radius_m", type=int, default=settings.radius_m)
    ap.add_argument("--skip_context", action="store_true")
    ap.add_argument("--skip_settlement", action="store_true")
    ap.add_argument("--context_step", type=int, default=10)
    args = ap.parse_args()

    if args.radius_m < 200 or args.radius_m > 1000:
        raise ValueError("radius_m must be in 200..1000")

    if args.context_step < 0:
        raise ValueError("context_step must be >= 0")

    run(
        radius_m=args.radius_m,
        skip_context=args.skip_context,
        skip_settlement=args.skip_settlement,
        context_step=args.context_step,
    )


if __name__ == "__main__":
    main()
