from __future__ import annotations

import os
import pandas as pd
import streamlit as st
import plotly.express as px
from streamlit_autorefresh import st_autorefresh

from agents.b1_dashboard.services.auth import get_role
from agents.b1_dashboard.services.data import load_tracks, load_dataset_points, compute_speed_series
from agents.b1_dashboard.services.external import fetch_current_weather, fetch_emergency_stub
from agents.b1_dashboard.services.alerts import recompute_speed_drop_alerts, load_alerts


st.set_page_config(page_title="Trails Dashboard", layout="wide")

st.title("Аналитика туристических маршрутов (Module B)")

# auto-refresh
refresh_sec = st.sidebar.slider("Auto refresh (seconds)", 5, 60, 15, 5)
st_autorefresh(interval=refresh_sec * 1000, key="autorefresh")

# auth
st.sidebar.subheader("Access")
pw = st.sidebar.text_input("Password", type="password")
role = get_role(pw)
st.sidebar.write(f"Role: **{role}**")

if role == "none":
    st.warning("Нужен пароль (viewer или admin).")
    st.stop()

tracks = load_tracks()
regions = ["ALL"] + sorted([r for r in tracks["region"].dropna().unique().tolist() if str(r).strip()])

region = st.sidebar.selectbox("Region", regions, index=0)

track_ids = tracks["id"].tolist()
track_id = st.sidebar.selectbox("Track", track_ids, index=0)

df = load_dataset_points(region=None if region == "ALL" else region)
df_track = df[df["track_id"] == track_id].copy()

# KPIs
c1, c2, c3, c4 = st.columns(4)
c1.metric("Tracks in DB", int(tracks.shape[0]))
c2.metric("Dataset points", int(df.shape[0]))
c3.metric("Points (selected track)", int(df_track.shape[0]))
c4.metric("Regions", int(len(regions) - 1))

st.divider()

# External data (weather now) for track start point
st.subheader("Внешние источники (best effort)")
if not df_track.empty:
    lat0 = float(df_track.iloc[0]["lat"])
    lon0 = float(df_track.iloc[0]["lon"])
    colw1, colw2 = st.columns([2, 3])
    with colw1:
        try:
            w = fetch_current_weather(lat0, lon0)
            st.success("Погода сейчас (Open-Meteo)")
            st.json(w)
        except Exception as e:
            st.warning(f"Погода недоступна: {e}")
    with colw2:
        st.info("ЧС/инциденты (заглушка)")
        st.json(fetch_emergency_stub())
else:
    st.info("Нет точек для выбранного трека, внешние источники не запрашиваем.")

st.divider()

# Map
st.subheader("Карта трека и фильтры")
if df_track.empty:
    st.info("Выбранный трек не имеет dataset_points.")
else:
    # Plotly map
    fig = px.scatter_mapbox(
        df_track,
        lat="lat",
        lon="lon",
        hover_data=["ts", "ele", "land_type"],
        zoom=10,
        height=450,
    )
    fig.update_layout(mapbox_style="open-street-map", margin={"r":0,"t":0,"l":0,"b":0})
    st.plotly_chart(fig, use_container_width=True)

st.divider()

# Advanced quick charts (для 2.2 будет расширяться)
st.subheader("Быстрые метрики и зависимости")
if not df_track.empty:
    left, right = st.columns(2)

    with left:
        st.caption("Распределение типов местности")
        land = df_track["land_type"].fillna("unknown").value_counts().reset_index()
        land.columns = ["land_type", "count"]
        st.plotly_chart(px.bar(land, x="land_type", y="count"), use_container_width=True)

    with right:
        st.caption("Высота по времени")
        tmp = df_track.copy()
        tmp["ts"] = pd.to_datetime(tmp["ts"], errors="coerce", utc=True)
        tmp = tmp.dropna(subset=["ts"])
        if tmp.empty:
            st.info("Нет ts для графика.")
        else:
            st.plotly_chart(px.line(tmp.sort_values("ts"), x="ts", y="ele"), use_container_width=True)

st.divider()

# Alerting
st.subheader("Алертинг: резкое падение активности (через скорость сегментов)")
if df_track.empty:
    st.info("Нет данных для алертинга.")
else:
    speed_df = compute_speed_series(df_track)
    th = st.slider("Speed threshold (m/s)", 0.1, 3.0, 0.5, 0.1)

    if role == "admin":
        if st.button("Пересчитать алерты по треку"):
            n = recompute_speed_drop_alerts(track_id=track_id, speed_df=speed_df, threshold_ms=th)
            st.success(f"Inserted alerts: {n}")

    st.caption("Скорость по сегментам")
    if not speed_df.empty and speed_df["speed_ms"].notna().any():
        st.plotly_chart(px.line(speed_df, x="track_point_id", y="speed_ms"), use_container_width=True)
    else:
        st.info("Скорость не вычислилась (нет времени или слишком мало точек).")

    st.caption("Последние алерты")
    alerts_df = load_alerts(track_id=track_id)
    st.dataframe(alerts_df, use_container_width=True, height=250)
